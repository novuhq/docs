---
pageTitle: 'Headless Inbox API Reference'
title: 'Headless API Reference'
description: 'Complete API reference for the Novu Headless Inbox package'
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { TypeTable } from 'fumadocs-ui/components/type-table';

export function FunctionParams({ children }) {
  return <div className="mt-4 mb-8">{children}</div>;
}

## Novu

`Novu` is the primary class used to interact with the Novu API client, enabling you to fetch and manage notifications and preferences within your custom Inbox implementation.

### Constructor Options

The Novu constructor accepts the following options:

| Option                | Type    | Required | Description                                     |
| --------------------- | ------- | -------- | ----------------------------------------------- |
| subscriberId          | string  | Yes      | The unique identifier of the subscriber         |
| applicationIdentifier | string  | Yes      | Your application identifier from Novu           |
| subscriberHash        | string  | No       | HMAC encryption hash for the subscriber         |
| backendUrl            | string  | No       | Custom backend URL for self-hosted instances    |
| socketUrl             | string  | No       | Custom socket URL for self-hosted instances     |
| useCache              | boolean | No       | Enable/disable response caching (default: true) |

### Usage

<Tabs items={['US', 'EU', 'HMAC Encryption']}>
  <Tab>
    ```typescript
    import { Novu } from "@novu/js";

    const novu = new Novu({
      subscriberId: "SUBSCRIBER_ID",
      applicationIdentifier: "APPLICATION_IDENTIFIER",
    });
    ```

  </Tab>
  <Tab>
    ```typescript
    import { Novu } from "@novu/js";

    const novu = new Novu({
      subscriberId: "SUBSCRIBER_ID",
      applicationIdentifier: "APPLICATION_IDENTIFIER",
      backendUrl: "https://eu.api.novu.co",
      socketUrl: "https://eu.ws.novu.co",
    });
    ```

  </Tab>
  <Tab>
    <Callout type="info">
      Read more about [HMAC Encryption](/platform/inbox/react/production#hmac-encryption).
    </Callout>

    ```typescript
    import { Novu } from "@novu/js";

    const novu = new Novu({
      subscriberId: "SUBSCRIBER_ID",
      applicationIdentifier: "APPLICATION_IDENTIFIER",
      subscriberHash: "SUBSCRIBER_HASH_HMAC_ENCRYPTION",
    });
    ```

  </Tab>
</Tabs>

### Modules Interface

- [Notifications](#notifications)
- [Preferences](#preferences)

## Notifications

### Methods

- [list](#list)
- [count](#count)
- [read](#read)
- [unread](#unread)
- [archive](#archive)
- [unarchive](#unarchive)
- [readAll](#readall)
- [archiveAll](#archiveall)
- [archiveAllRead](#archiveallread)
- [completePrimary](#completeprimary)
- [completeSecondary](#completesecondary)
- [revertPrimary](#revertprimary)
- [revertSecondary](#revertsecondary)

### Notification Interface

```typescript
type Subscriber = {
  id: string;
  firstName?: string;
  lastName?: string;
  avatar?: string;
  subscriberId: string;
};

enum ChannelType {
  IN_APP = 'in_app',
  EMAIL = 'email',
  SMS = 'sms',
  CHAT = 'chat',
  PUSH = 'push',
}

type Redirect = {
  url: string;
  target?: '_self' | '_blank' | '_parent' | '_top' | '_unfencedTop';
};

type Action = {
  label: string;
  isCompleted: boolean;
  redirect?: Redirect;
};

interface Notification {
  id: string;
  subject?: string;
  body: string;
  to: Subscriber;
  isRead: boolean;
  isArchived: boolean;
  createdAt: string;
  readAt?: string | null;
  archivedAt?: string | null;
  avatar?: string;
  primaryAction?: Action;
  secondaryAction?: Action;
  channelType: ChannelType;
  tags?: string[];
  data?: Record<string, unknown>;
  redirect?: Redirect;
}
```

### list

Method to fetch the list of notifications based on the provided filters.

<Callout type="info">
  By default, the response is cached internally and stored by provided filters as a key. The cache
  will be updated automatically with the subsequent response if the filters didn't change. All
  cached responses will be merged into a single list and returned as the result. You can disable
  this behaviour by setting the `useCache` parameter to `false` in the Novu constructor options.
</Callout>

### Filter Parameters

<TypeTable
  type={{
    tags: {
      type: 'string[]',
      description: 'Filter notifications by workflow tags',
    },
    read: {
      type: 'boolean',
      description: 'Filter by read status',
    },
    archived: {
      type: 'boolean',
      description: 'Filter by archived status',
    },
    limit: {
      type: 'number',
      description: 'Number of notifications to fetch (1-100, default: 10)',
    },
    after: {
      type: 'string',
      description: 'Fetch notifications after a specific notification ID',
    },
    offset: {
      type: 'number',
      description: 'Skip first N notifications',
    },
  }}
/>

### Response Type

<TypeTable
  type={{
    data: {
      type: 'object',
      description: 'Response data object',
      properties: {
        notifications: {
          type: 'Notification[]',
          description: 'Array of notification objects',
        },
        hasMore: {
          type: 'boolean',
          description: 'Whether there are more notifications to fetch',
        },
        filter: {
          type: 'NotificationFilter',
          description: 'Applied filter criteria',
        },
      },
    },
    error: {
      type: 'NovuError',
      description: 'Error object if request fails',
    },
  }}
/>

#### Example

```typescript
const notifications = await novu.notifications.list({
  limit: 30,
  read: false,
  archived: false,
  tags: ['tag1', 'tag2'],
  offset: 0,
});
```

### count

Method to fetch the count of read, unread, archived and unarchived notifications grouped by tags.

#### Parameters

| Parameter | Type     | Description                           |
| --------- | -------- | ------------------------------------- |
| tags      | string[] | Count notifications by workflow tags  |
| read      | boolean  | Count by read status                  |
| archived  | boolean  | Count by archived status              |
| filters   | Filter[] | Multiple filters for different counts |

#### Returns

<Tabs items={['Single Filter', 'Multiple Filters']}>
  <Tab>
    ```typescript
    interface FilterCountResponse {
      data: {
        count: number;
        filter: NotificationFilter;
      };
      error?: NovuError;
    }
    ```
  </Tab>
  <Tab>
    ```typescript
    interface FiltersCountResponse {
      data: {
        counts: {
          count: number;
          filter: NotificationFilter;
        }[];
      };
      error?: NovuError;
    }
    ```
  </Tab>
</Tabs>

#### Example

```typescript
// Single filter
const count = await novu.notifications.count({
  read: false,
  archived: false,
});

// Multiple filters
const counts = await novu.notifications.count({
  filters: [{ read: false }, { archived: true }, { tags: ['tag1'] }],
});
```

### read

Method marks a notification as read.

<TypeTable
  type={{
    notificationId: {
      type: 'string',
      description: 'The ID of the notification to mark as read',
      required: true,
    },
  }}
/>

### unread

Method marks a notification as unread.

<TypeTable
  type={{
    notificationId: {
      type: 'string',
      description: 'The ID of the notification to mark as unread',
      required: true,
    },
  }}
/>

### archive

Method marks a notification as archived.

<TypeTable
  type={{
    notificationId: {
      type: 'string',
      description: 'The ID of the notification to archive',
      required: true,
    },
  }}
/>

### unarchive

Method marks a notification as unarchived.

<TypeTable
  type={{
    notificationId: {
      type: 'string',
      description: 'The ID of the notification to unarchive',
      required: true,
    },
  }}
/>

### readAll

Method marks all notifications as read. Notifications can be filtered by tags.

<TypeTable
  type={{
    tags: {
      type: 'string[]',
      description:
        'Workflow tags can be used to filter notifications, and organize them into different groups. Read more about how can you define workflow tags.',
    },
  }}
/>

#### Usage

```typescript
await novu.notifications.readAll({
  tags: ['tag1', 'tag2'],
});
```

### archiveAll

Method marks all notifications as archived. Notifications can be filtered by tags.

<TypeTable
  type={{
    tags: {
      type: 'string[]',
      description:
        'Workflow tags can be used to filter notifications, and organize them into different groups. Read more about how can you define workflow tags.',
    },
  }}
/>

#### Usage

```typescript
await novu.notifications.archiveAll({
  tags: ['tag1', 'tag2'],
});
```

### archiveAllRead

Method marks all read notifications as archived. Notifications can be filtered by tags.

<TypeTable
  type={{
    tags: {
      type: 'string[]',
      description:
        'Workflow tags can be used to filter notifications, and organize them into different groups. Read more about how can you define workflow tags.',
    },
  }}
/>

#### Usage

```typescript
await novu.notifications.archiveAllRead({
  tags: ['tag1', 'tag2'],
});
```

### completePrimary

Method marks primary action of a notification as completed. It changes the `isCompleted` field of `primaryAction` to **done** from **pending**.

<TypeTable
  type={{
    notificationId: {
      type: 'string',
      description: 'The ID of the notification to mark as completed',
      required: true,
    },
  }}
/>

#### Usage

```typescript
await novu.notifications.completePrimary({
  notificationId: 'notification.id',
});
```

### completeSecondary

Method marks secondary action of a notification as completed. It changes the `isCompleted` field of `primaryAction` to **done** from **pending**.

<TypeTable
  type={{
    notificationId: {
      type: 'string',
      description: 'The ID of the notification to mark as completed',
      required: true,
    },
  }}
/>

#### Usage

```typescript
await novu.notifications.completeSecondary({
  notificationId: 'notification.id',
});
```

### revertPrimary

Method marks primary action of a notification as pending. It changes the `isCompleted` field of `primaryAction` to **pending** from **done**.

<TypeTable
  type={{
    notificationId: {
      type: 'string',
      description: 'The ID of the notification to revert to pending',
      required: true,
    },
  }}
/>

#### Usage

```typescript
await novu.notifications.revertPrimary({
  notificationId: 'notification.id',
});
```

### revertSecondary

Method marks secondary action of a notification as pending. It changes the `isCompleted` field of `secondaryAction` to **pending** from **done**.

<TypeTable
  type={{
    notificationId: {
      type: 'string',
      description: 'The ID of the notification to revert to pending',
      required: true,
    },
  }}
/>

#### Usage

```typescript
await novu.notifications.revertSecondary({
  notificationId: 'notification.id',
});
```

## Preferences

### Methods

- [list](#list)

### Preference Interface

```typescript
type Workflow = {
  id: string;
  identifier: string;
  name: string;
  critical: boolean;
  tags?: string[];
};

type ChannelPreference = {
  email?: boolean;
  sms?: boolean;
  in_app?: boolean;
  chat?: boolean;
  push?: boolean;
};

enum PreferenceLevel {
  GLOBAL = 'global',
  TEMPLATE = 'template',
}

interface Preference {
  enabled: boolean;
  workflow?: Workflow;
  channels: ChannelPreference;
  level: PreferenceLevel;
}
```

### list

Method fetch the global and workflows channel preferences of the subscriber.

#### Usage

```typescript
await novu.preferences.list();
```

## Preference

### Methods

- [update](#update)

### update

Update the global or per workflow channel preferences of the subscriber.

If `workflowId` is provided, it updates the channel preferences of the specific workflow. Otherwise, it updates the global channel preferences.

### Parameters

<TypeTable
  type={{
    workflowId: {
      type: 'string',
      description: 'The ID of the workflow to update preferences for',
    },
    channelPreferences: {
      type: 'ChannelPreference',
      description: 'The channel preferences to update',
    },
  }}
/>

```typescript
await preference.update({
  workflowId: 'workflow_id',
  channelPreferences: { email: false, sms: false },
});
```

## Events

### Usage

```typescript
novu.on('notifications.notification_received', (data) => {
  console.log('new notification =>', data);
});

novu.on('notifications.unread_count_changed', (data) => {
  console.log('new unread notifications count =>', data);
});
```
