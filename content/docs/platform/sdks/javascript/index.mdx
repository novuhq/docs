---
title: '@novu/js'
pageTitle: 'API reference for the @novu/js package'
description: 'Complete API reference for the Novu JavaScript package'
icon: 'Braces'
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

## Novu

The Novu client provides methods to interact with notifications, preferences, and real-time events.

### Constructor Options

<TypeTable name="NovuOptions" type={{
  "apiUrl": {
    "description": "",
    "type": "string"
  },
  "applicationIdentifier": {
    "description": "",
    "type": "string | undefined"
  },
  "subscriberHash": {
    "description": "",
    "type": "string"
  },
  "apiUrl": {
    "description": "",
    "type": "string"
  },
  "socketUrl": {
    "description": "",
    "type": "string"
  },
  "useCache": {
    "description": "",
    "type": "boolean"
  },
  "subscriberId": {
    "description": "",
    "type": "string"
  },
  "subscriber": {
    "description": "",
    "type": "string | Subscriber"
  }
}} />

### Usage

<Tabs items={['US', 'EU', 'HMAC Encryption']}>
  <Tab value="US">
    ```typescript
    import { Novu } from "@novu/js";

    const novu = new Novu({
      subscriberId: "SUBSCRIBER_ID",
      applicationIdentifier: "APPLICATION_IDENTIFIER",
    });
    ```
  </Tab>
  <Tab value="EU">
    ```typescript
    import { Novu } from "@novu/js";

    const novu = new Novu({
      subscriberId: "SUBSCRIBER_ID",
      applicationIdentifier: "APPLICATION_IDENTIFIER",
      apiUrl: "https://eu.api.novu.co",
      socketUrl: "wss://eu.socket.novu.co",
    });
    ```
  </Tab>
  <Tab value="HMAC Encryption">
    ```typescript
    import { Novu } from "@novu/js";

    const novu = new Novu({
      subscriberId: "SUBSCRIBER_ID",
      applicationIdentifier: "APPLICATION_IDENTIFIER",
      subscriberHash: "SUBSCRIBER_HASH_HMAC_ENCRYPTION",
    });
    ```
  </Tab>
</Tabs>

## Notifications

### Methods

#### list

Fetches a list of notifications based on provided filters.

<TypeTable name="NotificationFilter" type={{
  "tags": {
    "description": "",
    "type": "string[]"
  },
  "read": {
    "description": "",
    "type": "boolean"
  },
  "archived": {
    "description": "",
    "type": "boolean"
  },
  "snoozed": {
    "description": "",
    "type": "boolean"
  },
  "seen": {
    "description": "",
    "type": "boolean"
  },
  "severity": {
    "description": "",
    "type": "SeverityLevelEnum | SeverityLevelEnum[]"
  },
  "data": {
    "description": "",
    "type": "Record<string, unknown>"
  }
}} />

```typescript

import { SeverityLevelEnum } from '@novu/js';

const notifications = await novu.notifications.list({
  limit: 30,
  read: false,
  seen: false,
  archived: false,
  severity: [SeverityLevelEnum.HIGH, SeverityLevelEnum.MEDIUM],
  tags: ['tag1', 'tag2'],
  // data attributes
  data: {
    type: 'login',
  },
  offset: 0,
});
```

The response will be of type:

<TypeTable name="NotificationsResponse" type={{
  "notifications": {
    "description": "",
    "type": "Notification[]"
  },
  "hasMore": {
    "description": "",
    "type": "boolean"
  },
  "filter": {
    "description": "",
    "type": "NotificationFilter"
  }
}} />

#### count

Fetches the count of notifications based on filters.

<TypeTable name="NotificationFilter" type={{
  "tags": {
    "description": "",
    "type": "string[]"
  },
  "read": {
    "description": "",
    "type": "boolean"
  },
  "archived": {
    "description": "",
    "type": "boolean"
  },
  "snoozed": {
    "description": "",
    "type": "boolean"
  },
  "seen": {
    "description": "",
    "type": "boolean"
  },
  "severity": {
    "description": "",
    "type": "SeverityLevelEnum | SeverityLevelEnum[]"
  },
  "data": {
    "description": "",
    "type": "Record<string, unknown>"
  }
}} />

<Tabs items={['Single Filter', 'Multiple Filters']}>
  <Tab value="Single Filter">
    ```typescript
    // Single filter
    const count = await novu.notifications.count({
      read: false,
      severity: SeverityLevelEnum.HIGH,
      seen: false,
      archived: false,
       // data attributes
      data: {
        type: 'login',
      },
    });
    ```
  </Tab>
  <Tab value="Multiple Filters">
    ```typescript
    // Multiple filters
    const counts = await novu.notifications.count({
      filters: [{ read: false }, { severity: SeverityLevelEnum.HIGH }, { seen: false }, { archived: true }, { tags: ['tag1'] }, { data: { type: 'login' } }],
    });
    ```
  </Tab>
</Tabs>

#### read

Marks a notification as read.

```typescript
await novu.notifications.read({ notificationId: 'NOTIFICATION_ID' });
```

#### unread

Marks a notification as unread.

```typescript
await novu.notifications.unread({ notificationId: 'NOTIFICATION_ID' });
```

#### seen

Marks a notification as seen.

```typescript
await novu.notifications.seen({ notificationId: 'NOTIFICATION_ID' });
```

<Callout type="info">
**Seen vs Read**: Notifications can be "seen" (automatically tracked when visible) or "read" (explicitly marked by user interaction). The Inbox component automatically marks notifications as seen when they're visible for 1+ seconds using the browser's IntersectionObserver API. This automatic tracking batches requests for performance and works seamlessly with infinite scroll and pagination, while read status requires explicit user action.

**Why no `unseen` method?** Unlike `read`/`unread` which can be toggled, `seen` is designed as a one-way operation. Once a notification has been seen by a user, it remains seen. This reflects the natural user experience where visibility cannot be "undone". Use filtering with `seen: false` to get unseen notifications instead.
</Callout>

#### seenAll

Marks notifications as seen. It can be filtered either by notification IDs, tags, or data.

```typescript
// Mark specific notifications as seen
await novu.notifications.seenAll({
  notificationIds: ['NOTIFICATION_ID_1', 'NOTIFICATION_ID_2']
});

// Mark notifications by tags as seen
await novu.notifications.seenAll({
  tags: ['tag1', 'tag2']
});

// Mark notifications by data as seen
await novu.notifications.seenAll({
  data: { type: 'login' }
});

// Mark all notifications as seen (no filters)
await novu.notifications.seenAll();
```

#### archive

Archives a notification.

```typescript
await novu.notifications.archive({ notificationId: 'NOTIFICATION_ID' });
```

#### unarchive

Unarchives a notification.

```typescript
await novu.notifications.unarchive({ notificationId: 'NOTIFICATION_ID' });
```

#### readAll

Marks all notifications as read. Can be filtered by tags.

```typescript
await novu.notifications.readAll({
  tags: ['tag1', 'tag2'],
  // data attributes
  data: {
    type: 'login',
  },
});
```

#### archiveAll

Archives all notifications. Can be filtered by tags.

```typescript
await novu.notifications.archiveAll({
  tags: ['tag1', 'tag2'],
  // data attributes
  data: {
    type: 'login',
  },
});
```

#### archiveAllRead

Archives all read notifications. Can be filtered by tags.

```typescript
await novu.notifications.archiveAllRead({
  tags: ['tag1', 'tag2'],
  // data attributes
  data: {
    type: 'login',
  },
});
```

#### completePrimary

Marks primary action of a notification as completed.

```typescript
await novu.notifications.completePrimary({ notificationId: 'NOTIFICATION_ID' });
```

#### completeSecondary

Marks secondary action of a notification as completed.

```typescript
await novu.notifications.completeSecondary({ notificationId: 'NOTIFICATION_ID' });
```

#### revertPrimary

Reverts primary action of a notification to pending.

```typescript
await novu.notifications.revertPrimary({ notificationId: 'NOTIFICATION_ID' });
```

#### revertSecondary

Reverts secondary action of a notification to pending.

```typescript
await novu.notifications.revertSecondary({ notificationId: 'NOTIFICATION_ID' });
```

## Notification

Individual notification instances have their own methods for marking as seen, read, archived, etc. These methods are available directly on each notification object.

### Methods

- `seen()` - Marks the notification as seen
- `read()` - Marks the notification as read  
- `unread()` - Marks the notification as unread
- `archive()` - Archives the notification
- `unarchive()` - Unarchives the notification
- `completePrimary()` - Marks primary action as completed
- `completeSecondary()` - Marks secondary action as completed
- `revertPrimary()` - Reverts primary action to pending
- `revertSecondary()` - Reverts secondary action to pending

**Note:** The `seen()` method is only available on individual notification instances, not on the `novu.notifications` object. Use `novu.notifications.seenAll()` for bulk operations.

### Usage

```typescript
// Get notifications
const { data: notifications } = await novu.notifications.list();

// Mark a specific notification as seen using the instance method
await notifications[0].seen();

// Mark as read using the instance method
await notifications[0].read();

// Archive using the instance method
await notifications[0].archive();
```

## Preferences

### Methods

#### list

Fetches the subscriber's notification preferences.

```typescript
const preferences = await novu.preferences.list();
```

The response will be of type:

<TypeTable name="PreferenceResponse" type={{
  "level": {
    "description": "",
    "type": "PreferenceLevel"
  },
  "enabled": {
    "description": "",
    "type": "boolean"
  },
  "channels": {
    "description": "",
    "type": "ChannelPreference"
  },
  "overrides": {
    "description": "",
    "type": "IPreferenceOverride[]"
  },
  "workflow": {
    "description": "",
    "type": "Workflow"
  }
}} />

## Events

The Novu client provides real-time event handling through WebSocket connections.

### Available Events

- `notifications.notification_received`: Triggered when a new notification is received
- `notifications.unread_count_changed`: Triggered when the unread count changes
- `notifications.unseen_count_changed`: Triggered when the unseen count changes

### Usage

```typescript
novu.on('session.initialize.resolved', ({ data }: { data: Session }) => {
  console.log(data.unreadCount.total);
  console.log(data.unreadCount.severity[SeverityLevelEnum.HIGH]);
});

novu.on('notifications.notification_received', (data) => {
  console.log('New notification:', data);
});

novu.on('notifications.unread_count_changed', (data) => {
  console.log('Unread count:', data);
});

novu.on('notifications.unseen_count_changed', (data) => {
  console.log('Unseen count:', data);
});
```

## Types

### Notification

<TypeTable name="Notification" type={{
  "id": {
    "description": "",
    "type": "string"
  },
  "subject": {
    "description": "",
    "type": "string"
  },
  "body": {
    "description": "",
    "type": "string"
  },
  "to": {
    "description": "",
    "type": "Subscriber"
  },
  "isRead": {
    "description": "",
    "type": "boolean"
  },
  "isSeen": {
    "description": "",
    "type": "boolean"
  },
  "isArchived": {
    "description": "",
    "type": "boolean"
  },
  "isSnoozed": {
    "description": "",
    "type": "boolean"
  },
  "snoozedUntil": {
    "description": "",
    "type": "string | null"
  },
  "deliveredAt": {
    "description": "",
    "type": "string[]"
  },
  "createdAt": {
    "description": "",
    "type": "string"
  },
  "readAt": {
    "description": "",
    "type": "string | null"
  },
  "firstSeenAt": {
    "description": "",
    "type": "string | null"
  },
  "archivedAt": {
    "description": "",
    "type": "string | null"
  },
  "avatar": {
    "description": "",
    "type": "string"
  },
  "primaryAction": {
    "description": "",
    "type": "Action"
  },
  "secondaryAction": {
    "description": "",
    "type": "Action"
  },
  "channelType": {
    "description": "",
    "type": "ChannelType"
  },
  "tags": {
    "description": "",
    "type": "string[] | undefined"
  },
  "redirect": {
    "description": "",
    "type": "Redirect | undefined"
  },
  "data": {
    "description": "",
    "type": "NotificationData"
  },
  "workflow": {
    "description": "",
    "type": "Workflow"
  },
  "read": {
    "description": "",
    "type": "() => Result<Notification>"
  },
  "unread": {
    "description": "",
    "type": "() => Result<Notification>"
  },
  "seen": {
    "description": "",
    "type": "() => Result<Notification>"
  },
  "archive": {
    "description": "",
    "type": "() => Result<Notification>"
  },
  "unarchive": {
    "description": "",
    "type": "() => Result<Notification>"
  },
  "snooze": {
    "description": "",
    "type": "(snoozeUntil: string) => Result<Notification>"
  },
  "unsnooze": {
    "description": "",
    "type": "() => Result<Notification>"
  },
  "completePrimary": {
    "description": "",
    "type": "() => Result<Notification>"
  },
  "completeSecondary": {
    "description": "",
    "type": "() => Result<Notification>"
  },
  "revertPrimary": {
    "description": "",
    "type": "() => Result<Notification>"
  },
  "revertSecondary": {
    "description": "",
    "type": "() => Result<Notification>"
  },
  "on": {
    "description": "",
    "type": "<Key extends EventNames>(eventName: Key, listener: EventHandler<Events[Key]>) => () => void"
  },
  "off": {
    "description": "",
    "type": "<Key extends EventNames>(eventName: Key, listener: EventHandler<Events[Key]>) => void"
  }
}} />

### Subscriber

<TypeTable name="Subscriber" type={{
  "id": {
    "description": "",
    "type": "string"
  },
  "subscriberId": {
    "description": "",
    "type": "string"
  },
  "firstName": {
    "description": "",
    "type": "string"
  },
  "lastName": {
    "description": "",
    "type": "string"
  },
  "email": {
    "description": "",
    "type": "string"
  },
  "phone": {
    "description": "",
    "type": "string"
  },
  "avatar": {
    "description": "",
    "type": "string"
  },
  "locale": {
    "description": "",
    "type": "string"
  },
  "data": {
    "description": "",
    "type": "Record<string, unknown>"
  },
  "timezone": {
    "description": "",
    "type": "string"
  }
}} />
